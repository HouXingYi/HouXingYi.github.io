<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.1"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="HouXingYi&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="HouXingYi&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HouXingYi&#39;s blog">






  <link rel="canonical" href="http://yoursite.com/page/2/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>HouXingYi's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HouXingYi's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">即使跑得再远，也逃不出自己本身</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/21/2017-10-21-mongo/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HouXingYi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HouXingYi's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/10/21/2017-10-21-mongo/" class="post-title-link" itemprop="url">mongoDB常用操作</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-21T00:00:00+08:00">2017-10-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-29 20:12:26" itemprop="dateModified" datetime="2018-07-29T20:12:26+08:00">2018-07-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后端/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一些mongoDB常用的操作</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mongoDB中的一些基本概念与SQL的基本概念是不同的，这是我们学习mongoDB的时候需要注意与区分的。 <br></p>
<p>下面一个表格带我们来理解下mongoDB中的一些概念。</p>
<table>
<thead>
<tr>
<th style="text-align:left">SQL概念</th>
<th style="text-align:left">mongoDB概念</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">database</td>
<td style="text-align:left">database</td>
<td style="text-align:left">数据库</td>
</tr>
<tr>
<td style="text-align:left">table</td>
<td style="text-align:left">collection</td>
<td style="text-align:left">数据库表/集合</td>
</tr>
<tr>
<td style="text-align:left">row</td>
<td style="text-align:left">document</td>
<td style="text-align:left">数据记录行/文档</td>
</tr>
<tr>
<td style="text-align:left">column</td>
<td style="text-align:left">field</td>
<td style="text-align:left">数据字段/域</td>
</tr>
<tr>
<td style="text-align:left">index</td>
<td style="text-align:left">index</td>
<td style="text-align:left">索引</td>
</tr>
<tr>
<td style="text-align:left">table joins</td>
<td style="text-align:left"></td>
<td style="text-align:left">表连接，mongoDB不支持</td>
</tr>
<tr>
<td style="text-align:left">primary key</td>
<td style="text-align:left">primary key</td>
<td style="text-align:left">主键，mongoDB自动将_id字段设置为主键</td>
</tr>
</tbody>
</table>
<p>通过下图，更加直观的理解mongoDB的一些概念</p>
<p><img src="/images/show.png" alt="展示"></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>一个mongoDB可以建立多个数据库</p>
<p>通过命令show dbs来展现当前有多少数据库，名字分别叫什么</p>
<h3 id="文档（document）"><a href="#文档（document）" class="headerlink" title="文档（document）"></a>文档（document）</h3><p>在mongoDB中文档就是一组键值对(key-value)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>
<p>需要注意的点</p>
<ol>
<li>文档中的键/值对是有序的。</li>
<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>
<li>MongoDB区分类型和大小写。</li>
<li>MongoDB的文档不能有重复的键。</li>
<li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li>
</ol>
<h3 id="集合（collection）"><a href="#集合（collection）" class="headerlink" title="集合（collection）"></a>集合（collection）</h3><p>集合就是mongoDB文档组，类似关系型数据库中的表。一个数据库中有多个集合，可以用命令show collections来查看。集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p>
<h3 id="MongoDB-数据类型"><a href="#MongoDB-数据类型" class="headerlink" title="MongoDB 数据类型"></a>MongoDB 数据类型</h3><p>下表为MongoDB中常用的几种数据类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">SQL概念</th>
<th style="text-align:left">mongoDB概念</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td>
</tr>
<tr>
<td style="text-align:left">Integer</td>
<td style="text-align:left">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">布尔值。用于存储布尔值（真/假）。</td>
</tr>
<tr>
<td style="text-align:left">Double</td>
<td style="text-align:left">双精度浮点值。用于存储浮点值。</td>
</tr>
<tr>
<td style="text-align:left">Min/Max keys</td>
<td style="text-align:left">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td>
</tr>
<tr>
<td style="text-align:left">Array</td>
<td style="text-align:left">用于将数组或列表或多个值存储为一个键。</td>
</tr>
<tr>
<td style="text-align:left">Timestamp</td>
<td style="text-align:left">时间戳。记录文档修改或添加的具体时间。</td>
</tr>
<tr>
<td style="text-align:left">Object</td>
<td style="text-align:left">用于内嵌文档。</td>
</tr>
<tr>
<td style="text-align:left">Null</td>
<td style="text-align:left">用于创建空值。</td>
</tr>
<tr>
<td style="text-align:left">Symbol</td>
<td style="text-align:left">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td style="text-align:left">Object ID</td>
<td style="text-align:left">对象 ID。用于创建文档的 ID。</td>
</tr>
<tr>
<td style="text-align:left">Binary Data</td>
<td style="text-align:left">二进制数据。用于存储二进制数据。</td>
</tr>
<tr>
<td style="text-align:left">Code</td>
<td style="text-align:left">代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td style="text-align:left">Regular expression</td>
<td style="text-align:left">正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody>
</table>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>直接使用use命令创建数据库。如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use DATABASE_NAME</span><br></pre></td></tr></table></figure>
<p>使用show dbs展示当前已创建的数据库。</p>
<p>use数据库之后db命令表示当前数据库</p>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>使用下列命令删除数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure></p>
<p>使用下列命令删除集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.drop()</span><br></pre></td></tr></table></figure></p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure></p>
<p>document采用json语法</p>
<p>3.2 版本后还有以下几种语法可用于插入文档:</p>
<ul>
<li>db.collection.insertOne():向指定集合中插入一条文档数据</li>
<li>db.collection.insertMany():向指定集合中插入多条文档数据</li>
</ul>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><p>update() 方法用于更新已存在的文档。语法格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li>query : update的查询条件，类似sql update查询内where后面的。</li>
<li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li>
<li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>
<li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>
<li>writeConcern :可选，抛出异常的级别。</li>
</ul>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>remove() 方法的基本语法格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;justOne&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果你的 MongoDB 是 2.6 版本以后的，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>query :（可选）删除的文档的条件。</li>
<li>justOne : （可选）如果设为 true 或 1，则只删除一个文档。</li>
<li>writeConcern :（可选）抛出异常的级别。</li>
</ul>
<p>另：</p>
<p>remove() 方法已经过时了，现在官方推荐使用 deleteOne() 和 deleteMany() 方法。</p>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>MongoDB 查询数据的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure>
<ul>
<li>query ：可选，使用查询操作符指定查询条件</li>
<li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li>
</ul>
<p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.find().pretty()</span><br></pre></td></tr></table></figure>
<p>pretty() 方法以格式化的方式来显示所有文档。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是一些最基本的mongoDB的常用操作，若想看一些详情的文档和功能可以看官方的文档和一些教程。</p>
<p><strong>参考</strong></p>
<p><a href="https://docs.mongodb.com/?_ga=2.76410965.1778730410.1511524353-1232494664.1511524353" target="_blank" rel="noopener">mongoDB官方文档</a></p>
<p><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">mongoDB教程</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/20/2017-10-20-mongoose/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HouXingYi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HouXingYi's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/10/20/2017-10-20-mongoose/" class="post-title-link" itemprop="url">mongoose基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-20T00:00:00+08:00">2017-10-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-29 20:12:26" itemprop="dateModified" datetime="2018-07-29T20:12:26+08:00">2018-07-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后端/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Nodejs开发中，我们一般使用mongoose来操作mongoDB数据库。下面我么来学习下mongoose常用的用法。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>那要使用它，首先你得装上node.js和mongodb并启动mongodb数据库 <br></p>
<p>Github地址：<a href="https://github.com/Automattic/mongoose" target="_blank" rel="noopener">https://github.com/Automattic/mongoose</a> <br><br>API Docs：<a href="http://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">http://mongoosejs.com/docs/guide.html</a></p>
<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p>要学习mongoose首先要了解三个重要的概念，他们是Schema、Model、Document。它们的关系是Schema生成Model、Model创造Document。 <br></p>
<p>Schema类似于定义表结构，但并不完全准确。它用于创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个Schema会映射到mongodb中的一个collection。Schema不具备操作数据库的能力，主要用于定义结构。 <br></p>
<p>Model是由Schema编译而成的构造器，具有抽象属性和行为，可以对数据库进行增删查改。Model所能增删查改的具体值是由Schema定义的，Schema定义以外的值则没有效果。在mongoDB中一个数据库有多个collections（由Schema定义结构），而每个collections有多个document（类似js对象一般的键值对）。</p>
<p>Model的每一个实例（instance）就是一个文档document。Document是由Model创建的实体，它的操作也会影响数据库。</p>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>在使用前首先连接数据库（若没有则创建之）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line"></span><br><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/test&apos;); </span><br><span class="line">//已连接</span><br><span class="line">mongoose.connection.on(&apos;connected&apos;, function () &#123;    </span><br><span class="line">    console.log(&apos;已连接&apos;);  </span><br><span class="line">&#125;);    </span><br><span class="line">//连接错误</span><br><span class="line">mongoose.connection.on(&apos;error&apos;,function (err) &#123;    </span><br><span class="line">    console.log(&apos;出错&apos;);  </span><br><span class="line">&#125;);    </span><br><span class="line">//断开连接</span><br><span class="line">mongoose.connection.on(&apos;disconnected&apos;, function () &#123;    </span><br><span class="line">    console.log(&apos;断开连接&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其它事件可以自行查看：<a href="http://mongoosejs.com/docs/api.html#connection_Connection" target="_blank" rel="noopener">http://mongoosejs.com/docs/api.html#connection_Connection</a></p>
<h2 id="定义Schema"><a href="#定义Schema" class="headerlink" title="定义Schema"></a>定义Schema</h2><p>Schema是mongoose中需要事先定义的数据模式，类似于表结构，不过mongoDB中不叫表，叫collections。<br></p>
<p>模型可以看作mysql中的数据表，属性可以看作是字段，当然这个类比并不十分正确。<br></p>
<p>每个Schema对应当前连接的数据库的一个collection,若不存在则会自动创建。 <br></p>
<p>Schema不具备操作数据库的能力。 <br></p>
<p>下面我们来看下如何创建Schema</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">var blogSchema = new Schema(&#123;</span><br><span class="line">  title:  String,</span><br><span class="line">  author: String,</span><br><span class="line">  body:   String,</span><br><span class="line">  comments: [&#123; body: String, date: Date &#125;],</span><br><span class="line">  date: &#123; type: Date, default: Date.now &#125;,</span><br><span class="line">  hidden: Boolean,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    votes: Number,</span><br><span class="line">    favs:  Number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>type有下面这些，<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Buffer</code>、<code>Date</code>、<code>ObjectId</code>、<code>Mixed</code>类型</p>
<h2 id="生成Model"><a href="#生成Model" class="headerlink" title="生成Model"></a>生成Model</h2><p>模型Model是根据Schema编译出的构造器，或者称为类，通过Model可以实例化出文档对象document。 <br><br>下面根据Schema构建一个Model<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Blog = mongoose.model(&apos;Blog&apos;, blogSchema);</span><br></pre></td></tr></table></figure></p>
<p>Model实例化之后为document。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var blogInstance = new Blog(&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="常用数据库操作"><a href="#常用数据库操作" class="headerlink" title="常用数据库操作"></a>常用数据库操作</h2><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p><strong>document.save()</strong></p>
<p>model实例化后的document可用save新增文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//实例化model</span><br><span class="line">var blogInstance = new Blog(&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line">//调用save方法即插入一个新的document</span><br><span class="line">user.save(function (err, res) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        console.log(&quot;Error:&quot; + err);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        console.log(&quot;Res:&quot; + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>model.create()</strong></p>
<p>使用save()方法，需要先实例化为文档，再使用save()方法保存文档。而create()方法，则直接在模型Model上操作，并且可以同时新增多个文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Blog.create(&#123;name:&quot;xiaowang&quot;&#125;,&#123;name:&quot;xiaoli&quot;&#125;,function(err,doc1,doc2)&#123;</span><br><span class="line">  console.log(doc1);</span><br><span class="line">  console.log(doc2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询文档有以下三种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find()</span><br><span class="line">findById()</span><br><span class="line">findOne()</span><br></pre></td></tr></table></figure></p>
<p><strong>find()</strong><br>第一个参数表示查询条件，第二个参数用于控制返回的字段，第三个参数用于配置查询参数，第四个参数是回调函数，回调函数的形式为function(err,docs){}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.find(conditions, [projection], [options], [callback])</span><br></pre></td></tr></table></figure></p>
<p><strong>findById()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.findById(id, [projection], [options], [callback])</span><br></pre></td></tr></table></figure></p>
<p><strong>findOne()</strong><br>该方法返回查找到的所有实例的第一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.findOne([conditions], [projection], [options], [callback])</span><br></pre></td></tr></table></figure></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新文档有以下两种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update()</span><br><span class="line">updateMany()</span><br></pre></td></tr></table></figure></p>
<p><strong>update()</strong><br>第一个参数conditions为查询条件，第二个参数doc为需要修改的数据，第三个参数options为控制选项，第四个参数是回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.update(conditions, doc, [options], [callback])</span><br></pre></td></tr></table></figure></p>
<p><strong>updateMany()</strong><br>updateMany()与update()方法唯一的区别就是默认更新多个文档，即使设置{multi:false}也无法只更新第一个文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.updateMany(conditions, doc, [options], [callback])</span><br></pre></td></tr></table></figure></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>更新文档有以下三种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remove()</span><br><span class="line">findOneAndRemove()</span><br><span class="line">findByIdAndRemove()</span><br></pre></td></tr></table></figure></p>
<p><strong>remove()</strong></p>
<p>remove有两种形式，一种是文档的remove()方法，一种是Model的remove()方法。<br></p>
<p>下面介绍Model的remove()方法，该方法的第一个参数conditions为查询条件，第二个参数回调函数的形式如下function(err){}。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.remove(conditions, [callback])</span><br></pre></td></tr></table></figure>
<p>下面介绍文档的remove()方法，该方法的参数回调函数的形式如下function(err,doc){}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.remove([callback])</span><br></pre></td></tr></table></figure></p>
<p><strong>findOneAndRemove()</strong><br>model的remove()会删除符合条件的所有数据，如果只删除符合条件的第一条数据，则可以使用model的findOneAndRemove()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.findOneAndRemove(conditions, [options], [callback])</span><br></pre></td></tr></table></figure></p>
<p><strong>findByIdAndRemove()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.findByIdAndRemove(id, [options], [callback])</span><br></pre></td></tr></table></figure></p>
<h3 id="前后钩子"><a href="#前后钩子" class="headerlink" title="前后钩子"></a>前后钩子</h3><p>前后钩子即pre()和post()方法，又称为中间件，是在执行某些操作时可以执行的函数。中间件在schema上指定，类似于静态方法或实例方法等</p>
<p>可以在数据库执行下列操作时，设置前后钩子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">init</span><br><span class="line">validate</span><br><span class="line">save</span><br><span class="line">remove</span><br><span class="line">count</span><br><span class="line">find</span><br><span class="line">findOne</span><br><span class="line">findOneAndRemove</span><br><span class="line">findOneAndUpdate</span><br><span class="line">insertMany</span><br><span class="line">update</span><br></pre></td></tr></table></figure></p>
<p><strong>pre()</strong><br>以find()方法为例，在执行find()方法之前，执行pre()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var schema = new mongoose.Schema(&#123; age:Number, name: String,x:Number,y:Number&#125;);  </span><br><span class="line">schema.pre(&apos;find&apos;,function(next)&#123;</span><br><span class="line">    console.log(&apos;我是pre方法1&apos;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">schema.pre(&apos;find&apos;,function(next)&#123;</span><br><span class="line">    console.log(&apos;我是pre方法2&apos;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);  </span><br><span class="line">var temp = mongoose.model(&apos;temp&apos;, schema);</span><br><span class="line">temp.find(function(err,docs)&#123;</span><br><span class="line">    console.log(docs[0]);</span><br><span class="line">&#125;)    </span><br><span class="line">/*</span><br><span class="line">我是pre方法1</span><br><span class="line">我是pre方法2</span><br><span class="line">&#123; _id: 5972ed35e6f98ec60e3dc886,name: &apos;huochai&apos;,age: 27,x: 1,y: 2 &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<h3 id="查询后处理"><a href="#查询后处理" class="headerlink" title="查询后处理"></a>查询后处理</h3><p>常用的查询后处理的方法如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sort     排序</span><br><span class="line">skip     跳过</span><br><span class="line">limit    限制</span><br><span class="line">select   显示字段</span><br><span class="line">exect    执行</span><br><span class="line">count    计数</span><br><span class="line">distinct 去重</span><br></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//按照age从小到大排列</span><br><span class="line">temp.find().sort(&quot;age&quot;).exec(function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="文档验证"><a href="#文档验证" class="headerlink" title="文档验证"></a>文档验证</h3><p>如果不进行文档验证，保存文档时，就可以不按照Schema设置的字段进行设置，分为以下几种情况</p>
<ol>
<li>缺少字段的文档可以保存成功</li>
<li>包含未设置的字段的文档也可以保存成功，未设置的字段不被保存</li>
<li>包含字段类型与设置不同的字段的文档也可以保存成功，不同字段类型的字段被保存为设置的字段类型</li>
</ol>
<p>而通过文档验证，就可以避免以上几种情况发生 <br><br>文档验证在SchemaType中定义，格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: &#123;type:String, validator:value&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>常用验证包括以下几种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">required: 数据必须填写</span><br><span class="line">default: 默认值</span><br><span class="line">validate: 自定义匹配</span><br><span class="line">min: 最小值(只适用于数字)</span><br><span class="line">max: 最大值(只适用于数字)</span><br><span class="line">match: 正则匹配(只适用于字符串)</span><br><span class="line">enum:  枚举匹配(只适用于字符串)</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xiaohuochai/p/7215067.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">Mongoose基础入门</a> <br><br><a href="http://www.cnblogs.com/zhongweiv/p/mongoose.html" target="_blank" rel="noopener">Mongoose介绍和入门</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/11/2017-10-11-net/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HouXingYi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HouXingYi's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/10/11/2017-10-11-net/" class="post-title-link" itemprop="url">HTTP与TCP/IP网络协议基础知识与重点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-11 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-11T00:00:00+08:00">2017-10-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-29 20:12:26" itemprop="dateModified" datetime="2018-07-29T20:12:26+08:00">2018-07-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/基础/" itemprop="url" rel="index"><span itemprop="name">基础</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/6e9e4156ece3" target="_blank" rel="noopener">一篇文章带你详解 HTTP 协议</a> <br><br><a href="http://www.jianshu.com/p/9f3e879a4c9c" target="_blank" rel="noopener">一篇文章带你熟悉 TCP/IP 协议</a> <br><br><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">图解HTTP</a> <br><br><a href="https://book.douban.com/subject/24737674/" target="_blank" rel="noopener">图解TCP/IP</a> </p>
<h2 id="HTTP协议重点"><a href="#HTTP协议重点" class="headerlink" title="HTTP协议重点"></a>HTTP协议重点</h2><h3 id="1-常用的HTTP方法"><a href="#1-常用的HTTP方法" class="headerlink" title="1.常用的HTTP方法"></a>1.常用的HTTP方法</h3><ul>
<li><strong>GET</strong>： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。</li>
<li><strong>POST</strong>：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li><strong>PUT</strong>： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li><strong>HEAD</strong>： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li><strong>DELETE</strong>：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li><strong>OPTIONS</strong>：查询相应URI支持的HTTP方法。</li>
</ul>
<h3 id="2-GET方法与POST方法的区别"><a href="#2-GET方法与POST方法的区别" class="headerlink" title="2.GET方法与POST方法的区别"></a>2.GET方法与POST方法的区别</h3><ul>
<li>区别一：<br><br>get重点在从服务器上获取资源，post重点在向服务器发送数据；</li>
<li>区别二：<br><br>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；" target="_blank" rel="noopener">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；</a><br><br>post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；</li>
<li>区别三：<br><br>Get传输的数据量小，因为受URL长度限制，但效率较高；<br><br>Post可以传输大量数据，所以上传文件时只能用Post方式；</li>
<li>区别四：<br><br>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；<br><br>post较get安全性较高；</li>
<li>区别五：<br><br>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。<br><br>post支持标准字符集，可以正确传递中文字符</li>
</ul>
<h3 id="3-HTTP请求报文与响应报文格式"><a href="#3-HTTP请求报文与响应报文格式" class="headerlink" title="3.HTTP请求报文与响应报文格式"></a>3.HTTP请求报文与响应报文格式</h3><ul>
<li>请求报文包含三部分：</li>
</ul>
<ol>
<li>请求行：包含请求方法、URI、HTTP版本信息</li>
<li>请求首部字段</li>
<li>请求内容实体</li>
</ol>
<ul>
<li>响应报文包含三部分：</li>
</ul>
<ol>
<li>状态行：包含HTTP版本、状态码、状态码的原因短语</li>
<li>响应首部字段</li>
<li>响应内容实体</li>
</ol>
<h3 id="4-常见的HTTP相应状态码"><a href="#4-常见的HTTP相应状态码" class="headerlink" title="4.常见的HTTP相应状态码"></a>4.常见的HTTP相应状态码</h3><ul>
<li><p>返回的状态<br><br><strong>1xx</strong>：指示信息–表示请求已接收，继续处理<br><br><strong>2xx</strong>：成功–表示请求已被成功接收、理解、接受<br><br><strong>3xx</strong>：重定向–要完成请求必须进行更进一步的操作<br><br><strong>4xx</strong>：客户端错误–请求有语法错误或请求无法实现<br><br><strong>5xx</strong>：服务器端错误–服务器未能实现合法的请求<br><br><br></p>
</li>
<li><p>常见状态码<br><br><strong>200</strong>：请求被正常处理<br><br><strong>204</strong>：请求被受理但没有资源可以返回<br><br><strong>206</strong>：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。<br><br><strong>301</strong>：永久性重定向<br><br><strong>302</strong>：临时重定向<br><br><strong>303</strong>：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上<br><br><strong>304</strong>：发送附带条件的请求时，条件不满足时返回，与重定向无关<br><br><strong>307</strong>：临时重定向，与302类似，只是强制要求使用POST方法<br><br><strong>400</strong>：请求报文语法有误，服务器无法识别<br><br><strong>401</strong>：请求需要认证<br><br><strong>403</strong>：请求的对应资源禁止被访问<br><br><strong>404</strong>：服务器无法找到对应资源<br><br><strong>500</strong>：服务器内部错误<br><br><strong>503</strong>：服务器正忙</p>
</li>
</ul>
<h2 id="TCP-IP协议重点"><a href="#TCP-IP协议重点" class="headerlink" title="TCP/IP协议重点"></a>TCP/IP协议重点</h2><h3 id="1-计算机网络体系结构分层"><a href="#1-计算机网络体系结构分层" class="headerlink" title="1.计算机网络体系结构分层"></a>1.计算机网络体系结构分层</h3><p><img src="/images/http/pic1.png" alt="分层模型"></p>
<h3 id="2-数据处理流程"><a href="#2-数据处理流程" class="headerlink" title="2.数据处理流程"></a>2.数据处理流程</h3><p><img src="/images/http/pic2.png" alt="数据处理流程"></p>
<h3 id="3-TCP连接建立、释放时的握手过程"><a href="#3-TCP连接建立、释放时的握手过程" class="headerlink" title="3.TCP连接建立、释放时的握手过程　　"></a>3.TCP连接建立、释放时的握手过程　　</h3><p><strong>三次握手</strong> <br></p>
<ul>
<li>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</li>
<li>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。<br><br><br>下面来看看三次握手的流程图：<br><img src="/images/http/pic3.png" alt="流程图"></li>
<li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li>
<li>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li>
<li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。<br><br><br><strong>四次挥手</strong> <br></li>
<li>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</li>
<li>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。<br><br><br>下面来看看四次挥手的流程图：<br><img src="/images/http/pic4.png" alt="流程图"></li>
<li>中断连接端可以是客户端，也可以是服务器端。</li>
<li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
<li>第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li>
<li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li>
<li>第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的都是些网络协议方面的老生常谈的基础知识，其中内容十分不完整和全面。主要是要有一些网络方面的基础概念，遇到问题的时候懂得要到哪里去查，一些细的方面的知识可以等到实际应用中去体会。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/2017-10-10-routes-in-100-line/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HouXingYi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HouXingYi's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/10/10/2017-10-10-routes-in-100-line/" class="post-title-link" itemprop="url">[译]一个100行内的现代js路由</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-10 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-10T00:00:00+08:00">2017-10-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-29 20:12:26" itemprop="dateModified" datetime="2018-07-29T20:12:26+08:00">2018-07-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文:http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url</span><br><span class="line">作者:Krasimir</span><br></pre></td></tr></table></figure>
<p>(这个js路由现在被放项目<a href="https://github.com/krasimir/navigo" target="_blank" rel="noopener">Navigo</a>中。这里还有一篇你可能会感兴趣的文章<a href="http://krasimirtsonev.com/blog/article/deep-dive-into-client-side-routing-navigo-pushstate-hash" target="_blank" rel="noopener">Deep dive into client-side routing</a>)</p>
<p>现今到处都是流行的单页面应用（SPA）。这样的应用需要一个坚实的路由机制。像<a href="https://emberjs.com/" target="_blank" rel="noopener">Emberjs</a>这样的框架确实是在建立在一个路由类上的。我不确定这是不是我喜欢的概念，但我确定的是<a href="http://absurdjs.com/" target="_blank" rel="noopener">AbsurdJS</a>需要一个内置的路由。并且这个路由在所有东西齐全的前提下，应该小巧、简单。那就让我们来看看这样一个模块是怎么样的。</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>这个路由应该符合下面几点</p>
<ol>
<li>应该小于100行</li>
<li>支持像<em><a href="http://site.com#products/list" target="_blank" rel="noopener">http://site.com#products/list</a></em>这样的hash类型的url</li>
<li>也能使用History API</li>
<li>提供易用的API</li>
<li>不会自动的运行</li>
<li>可选择监听改变</li>
</ol>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>我决定把路由做成只有一个实例。这也许是个坏决定，因为我就有个项目需要多个路由，但要知道这个不是常有的应用。如果我们使用单例模式，我们就不需要把路由从一个对象传到另一个对象并且我们也不需要创建它。我们只需要一个实例，这样我们就可以自动的创建它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Router = &#123;</span><br><span class="line">    routes: [],</span><br><span class="line">    mode: null,</span><br><span class="line">    root: &apos;/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有三个我们需要的属性。</p>
<ul>
<li>routes-这个保存着当前已注册的路由</li>
<li>mode-根据我们使用的是history还是hash显示’hash’或者’history’</li>
<li>root-应用的根URL路径，只有当我们使用pushState的时候我们才需要</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我们需要一个方法来初始化路由。我们只需要传两个东西，但是最好在一个函数内做这些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Router = &#123;</span><br><span class="line">    routes: [],</span><br><span class="line">    mode: null,</span><br><span class="line">    root: &apos;/&apos;,</span><br><span class="line">    config: function(options) &#123;</span><br><span class="line">        this.mode = options &amp;&amp; options.mode &amp;&amp; options.mode == &apos;history&apos; </span><br><span class="line">                    &amp;&amp; !!(history.pushState) ? &apos;history&apos; : &apos;hash&apos;;</span><br><span class="line">        this.root = options &amp;&amp; options.root ? &apos;/&apos; + this.clearSlashes(options.root) + &apos;/&apos; : &apos;/&apos;;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当我们想要使用history模式并且支持<em>pushState</em>的时候，mode才会等于’history’。否则我们将使用hash。root默认设置为单斜线’/‘。</p>
<h2 id="获得当前的URL"><a href="#获得当前的URL" class="headerlink" title="获得当前的URL"></a>获得当前的URL</h2><p>这是我们的路由的重要部分，因为这将会告诉我们现在在什么地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getFragment: function() &#123;</span><br><span class="line">    var fragment = &apos;&apos;;</span><br><span class="line">    if(this.mode === &apos;history&apos;) &#123;</span><br><span class="line">        fragment = this.clearSlashes(decodeURI(location.pathname + location.search));</span><br><span class="line">        fragment = fragment.replace(/\?(.*)$/, &apos;&apos;);</span><br><span class="line">        fragment = this.root != &apos;/&apos; ? fragment.replace(this.root, &apos;&apos;) : fragment;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var match = window.location.href.match(/#(.*)$/);</span><br><span class="line">        fragment = match ? match[1] : &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.clearSlashes(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在两个例子中我们都是用了全局的<em>window.location</em>对象。在’history’模式版本中我们需要去掉URL的根部分。我们也需要去掉所有的GET请求参数，我们用如下的正则表达式搞定-<code>(/\?(.*)$/)</code>。获取hash的值则更加简单点。注意<em>clearSlashes</em>函数的作用。它的用处是去除字符串开头和结尾的斜杠。这是有必要的，因为我们不能强迫开发者使用特定格式的URL。无论他传什么都会转成同样的值。</p>
<h2 id="添加和修改路由"><a href="#添加和修改路由" class="headerlink" title="添加和修改路由"></a>添加和修改路由</h2><p>当我在制作<a href="http://absurdjs.com/" target="_blank" rel="noopener">AbsurdJS</a>的时候，我总是尝试尽可能多的给开发者控制权。几乎所有的路由插件在执行路由的时候是用字符串路由。然而我更喜欢传一个正则表达式。这更加的灵活，因为有的时候我们也许会做很奇怪的匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add: function(re, handler) &#123;</span><br><span class="line">    if(typeof re == &apos;function&apos;) &#123;</span><br><span class="line">        handler = re;</span><br><span class="line">        re = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    this.routes.push(&#123; re: re, handler: handler&#125;);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个将<em>routes</em>数组进行填充。如果只有一个函数传进来，那么这个函数就会被作为handler，而默认的路由就是一个空字符串。注意这里大部分的函数return this。这可以让我们链式调用方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remove: function(param) &#123;</span><br><span class="line">    for(var i=0, r; i&lt;this.routes.length, r = this.routes[i]; i++) &#123;</span><br><span class="line">        if(r.handler === param || r.re.toString() === param.toString()) &#123;</span><br><span class="line">            this.routes.splice(i, 1); </span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有我们传一个正则表达式或者handler传给<em>add</em>方法的时候，路由的删除才会调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flush: function() &#123;</span><br><span class="line">    this.routes = [];</span><br><span class="line">    this.mode = null;</span><br><span class="line">    this.root = &apos;/&apos;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有的时候我们需要重新初始化类。那么这时候你就可以用上面的<em>flush</em>方法。</p>
<h2 id="登记"><a href="#登记" class="headerlink" title="登记"></a>登记</h2><p>好，现在我们已经有了增加和删除URL的API。我们也可以得到当前的地址了。下一步我们要比较已注册的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">check: function(f) &#123;</span><br><span class="line">    var fragment = f || this.getFragment();</span><br><span class="line">    for(var i=0; i&lt;this.routes.length; i++) &#123;</span><br><span class="line">        var match = fragment.match(this.routes[i].re);</span><br><span class="line">        if(match) &#123;</span><br><span class="line">            match.shift();</span><br><span class="line">            this.routes[i].handler.apply(&#123;&#125;, match);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过传入函数作为参数或者调用<em>getFragment</em>方法来获得<em>fragment</em>。接下来我们执行一个单纯的循环来遍历routes来查看匹配。只有当正则表达式没有匹配到的时候，变量<em>match</em>的值是null。否则<em>match</em>的值会像下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;products/12/edit/22&quot;, &quot;12&quot;, &quot;22&quot;, index: 1, input: &quot;/products/12/edit/22&quot;]</span><br></pre></td></tr></table></figure></p>
<p>这是一个包含了匹配到的数组和所有可记录的子串的类数组。这意味着如果我们<em>shift</em>第一个我们会获得URL动态部分的数组。举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Router</span><br><span class="line">.add(/about/, function() &#123;</span><br><span class="line">    console.log(&apos;about&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.add(/products\/(.*)\/edit\/(.*)/, function() &#123;</span><br><span class="line">    console.log(&apos;products&apos;, arguments);</span><br><span class="line">&#125;)</span><br><span class="line">.add(function() &#123;</span><br><span class="line">    console.log(&apos;default&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.check(&apos;/products/12/edit/22&apos;);</span><br></pre></td></tr></table></figure></p>
<p>这段脚本输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">products [&quot;12&quot;, &quot;22&quot;]</span><br></pre></td></tr></table></figure></p>
<p>到此为止我们处理了动态URL。</p>
<h2 id="监听变化"><a href="#监听变化" class="headerlink" title="监听变化"></a>监听变化</h2><p>当然我们不能总是调用<em>check</em>方法。我们需要当地址栏改变的时候，我们能收到通知。我所说的改变甚至意味着点击浏览器上的后退按钮。如果你用过History API的话你就会知道有一个<em>popstate</em>事件。当URL改变的时候就会触发这个事件。然而我发现在一些浏览器中，当页面加载完的时候会分发这个事件。这个情况加上其他的一些问题让我转向了其他的解决方案。因为我希望甚至在模式被设置为hash也能进行监听，我决定采用setinterval。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">listen: function() &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    var current = self.getFragment();</span><br><span class="line">    var fn = function() &#123;</span><br><span class="line">        if(current !== self.getFragment()) &#123;</span><br><span class="line">            current = self.getFragment();</span><br><span class="line">            self.check(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clearInterval(this.interval);</span><br><span class="line">    this.interval = setInterval(fn, 50);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要把最近的URL存下来这样我们才能用于对比下一个。</p>
<h2 id="改变URL"><a href="#改变URL" class="headerlink" title="改变URL"></a>改变URL</h2><p>最后我们需要一个函数能改变当前的地址并触发路由handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">navigate: function(path) &#123;</span><br><span class="line">    path = path ? path : &apos;&apos;;</span><br><span class="line">    if(this.mode === &apos;history&apos;) &#123;</span><br><span class="line">        history.pushState(null, null, this.root + this.clearSlashes(path));</span><br><span class="line">    &#125; else &#123;        </span><br><span class="line">        window.location.href = window.location.href.replace(/#(.*)$/, &apos;&apos;) + &apos;#&apos; + path;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的，我们根据不同的模式做不同的事。如果History API可用，我们使用<em>pushState</em>。否则我们就采用window.location。</p>
<h2 id="最终源码"><a href="#最终源码" class="headerlink" title="最终源码"></a>最终源码</h2><p>以下是最终源码加一点例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">var Router = &#123;</span><br><span class="line">    routes: [],</span><br><span class="line">    mode: null,</span><br><span class="line">    root: &apos;/&apos;,</span><br><span class="line">    config: function(options) &#123;</span><br><span class="line">        this.mode = options &amp;&amp; options.mode &amp;&amp; options.mode == &apos;history&apos; </span><br><span class="line">                    &amp;&amp; !!(history.pushState) ? &apos;history&apos; : &apos;hash&apos;;</span><br><span class="line">        this.root = options &amp;&amp; options.root ? &apos;/&apos; + this.clearSlashes(options.root) + &apos;/&apos; : &apos;/&apos;;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    getFragment: function() &#123;</span><br><span class="line">        var fragment = &apos;&apos;;</span><br><span class="line">        if(this.mode === &apos;history&apos;) &#123;</span><br><span class="line">            fragment = this.clearSlashes(decodeURI(location.pathname + location.search));</span><br><span class="line">            fragment = fragment.replace(/\?(.*)$/, &apos;&apos;);</span><br><span class="line">            fragment = this.root != &apos;/&apos; ? fragment.replace(this.root, &apos;&apos;) : fragment;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var match = window.location.href.match(/#(.*)$/);</span><br><span class="line">            fragment = match ? match[1] : &apos;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.clearSlashes(fragment);</span><br><span class="line">    &#125;,</span><br><span class="line">    clearSlashes: function(path) &#123;</span><br><span class="line">        return path.toString().replace(/\/$/, &apos;&apos;).replace(/^\//, &apos;&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    add: function(re, handler) &#123;</span><br><span class="line">        if(typeof re == &apos;function&apos;) &#123;</span><br><span class="line">            handler = re;</span><br><span class="line">            re = &apos;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        this.routes.push(&#123; re: re, handler: handler&#125;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: function(param) &#123;</span><br><span class="line">        for(var i=0, r; i&lt;this.routes.length, r = this.routes[i]; i++) &#123;</span><br><span class="line">            if(r.handler === param || r.re.toString() === param.toString()) &#123;</span><br><span class="line">                this.routes.splice(i, 1); </span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    flush: function() &#123;</span><br><span class="line">        this.routes = [];</span><br><span class="line">        this.mode = null;</span><br><span class="line">        this.root = &apos;/&apos;;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    check: function(f) &#123;</span><br><span class="line">        var fragment = f || this.getFragment();</span><br><span class="line">        for(var i=0; i&lt;this.routes.length; i++) &#123;</span><br><span class="line">            var match = fragment.match(this.routes[i].re);</span><br><span class="line">            if(match) &#123;</span><br><span class="line">                match.shift();</span><br><span class="line">                this.routes[i].handler.apply(&#123;&#125;, match);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    listen: function() &#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        var current = self.getFragment();</span><br><span class="line">        var fn = function() &#123;</span><br><span class="line">            if(current !== self.getFragment()) &#123;</span><br><span class="line">                current = self.getFragment();</span><br><span class="line">                self.check(current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clearInterval(this.interval);</span><br><span class="line">        this.interval = setInterval(fn, 50);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    navigate: function(path) &#123;</span><br><span class="line">        path = path ? path : &apos;&apos;;</span><br><span class="line">        if(this.mode === &apos;history&apos;) &#123;</span><br><span class="line">            history.pushState(null, null, this.root + this.clearSlashes(path));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            window.location.href = window.location.href.replace(/#(.*)$/, &apos;&apos;) + &apos;#&apos; + path;</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// configuration</span><br><span class="line">Router.config(&#123; mode: &apos;history&apos;&#125;);</span><br><span class="line"></span><br><span class="line">// returning the user to the initial state</span><br><span class="line">Router.navigate();</span><br><span class="line"></span><br><span class="line">// adding routes</span><br><span class="line">Router</span><br><span class="line">.add(/about/, function() &#123;</span><br><span class="line">    console.log(&apos;about&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.add(/products\/(.*)\/edit\/(.*)/, function() &#123;</span><br><span class="line">    console.log(&apos;products&apos;, arguments);</span><br><span class="line">&#125;)</span><br><span class="line">.add(function() &#123;</span><br><span class="line">    console.log(&apos;default&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.check(&apos;/products/12/edit/22&apos;).listen();</span><br><span class="line"></span><br><span class="line">// forwarding</span><br><span class="line">Router.navigate(&apos;/about&apos;);</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个路由大概90行。支持hash类型的URL和新的history API。如果你不想仅仅想使用路由这个功能而使用整个框架，这个就对你是有帮助的。</p>
<p>这个类是<a href="http://absurdjs.com/" target="_blank" rel="noopener">AbsurdJS</a>的一部分。在<a href="http://absurdjs.com/pages/api/build-in-components/#router" target="_blank" rel="noopener">这里</a>可以查看文档。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/10/2017-8-10-regex/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HouXingYi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HouXingYi's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/10/2017-8-10-regex/" class="post-title-link" itemprop="url">入门正则表达式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-10 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-10T00:00:00+08:00">2017-08-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-29 20:12:26" itemprop="dateModified" datetime="2018-07-29T20:12:26+08:00">2018-07-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/基础/" itemprop="url" rel="index"><span itemprop="name">基础</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a><br><a href="https://juejin.im/post/582455e467f3560058c6641e" target="_blank" rel="noopener">《JavaScript 闯关记》之正则表达式</a>   </p>
<h2 id="正则表达式是什么"><a href="#正则表达式是什么" class="headerlink" title="正则表达式是什么"></a>正则表达式是什么</h2><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<h2 id="为什么要用正则表达式"><a href="#为什么要用正则表达式" class="headerlink" title="为什么要用正则表达式"></a>为什么要用正则表达式</h2><ul>
<li>密码、账号等验证。</li>
<li>看源码需要，写框架，后端编程，路由都离不开正则</li>
</ul>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><a href="http://www.runoob.com/regexp/regexp-metachar.html" target="_blank" rel="noopener">常用的正则表达式元字符</a></p>
<h2 id="例子加深理解"><a href="#例子加深理解" class="headerlink" title="例子加深理解"></a>例子加深理解</h2><ol>
<li>例子一 <br></li>
</ol>
<ul>
<li>正则表达式:<code>\bhi\b.*\bLucy\b</code></li>
<li>含义:先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词</li>
<li>知识点:  <ol>
<li><code>\b</code>:代表着<em>单词的开头或结尾，也就是单词的分界处</em> </li>
<li><code>.</code>:匹配<em>除了换行符以外的任意字符</em></li>
<li><code>*</code>:它指定<em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配</em></li>
</ol>
</li>
</ul>
<ol start="2">
<li>例子二     </li>
</ol>
<ul>
<li>正则表达式:<code>0\d\d-\d\d\d\d\d\d\d\d</code> 或 <code>0\d{2}-\d{8}</code></li>
<li>含义:以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字</li>
<li>知识点:<ol>
<li><code>\d</code>:匹配<em>一位数字</em> </li>
<li><code>{n}</code>:匹配<em>必须连续重复匹配2次</em></li>
</ol>
</li>
</ul>
<ol start="3">
<li>例子三     </li>
</ol>
<ul>
<li>正则表达式:<code>\ba\w*\b</code></li>
<li>含义:a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)</li>
<li>知识点:<ol>
<li><code>\w</code>:匹配<em>字母或数字或下划线或汉字等</em> </li>
<li><code>\s</code>:匹配<em>任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等</em>（虽然这里没有）</li>
</ol>
</li>
</ul>
<h2 id="还有一些元字符"><a href="#还有一些元字符" class="headerlink" title="还有一些元字符"></a>还有一些元字符</h2><ol>
<li><code>^</code>:匹配<em>匹配字符串的开始</em> </li>
<li><code>$</code>:匹配<em>匹配字符串的结束</em></li>
<li><code>{n,m}</code>:重复的次数不能少于n次，不能多于m次</li>
<li><code>\</code>:标记为一个元字符、或一个原义字符、或一个 向后引用、或一个八进制转义符</li>
<li><p>重复：</p>
<p> 代码/语法 | 说明 </p>
<ul>
<li>| -</li>
</ul>
<ul>
<li>| 重复零次或更多次</li>
</ul>
<ul>
<li>| 重复一次或更多次<br>? | 重复零次或一次<br>{n} | 重复n次<br>{n,} | 重复n次或更多次<br>{n,m} | 重复n到m次</li>
</ul>
</li>
<li><p>字符类</p>
<p> 匹配没有预定义元字符的字符集合 : 只需要在方括号里列出它们就行了 <br><br> 如：<code>[aeiou]</code>就匹配任何一个英文元音字母</p>
</li>
</ol>
<h2 id="一些稍微高级的话题"><a href="#一些稍微高级的话题" class="headerlink" title="一些稍微高级的话题"></a>一些稍微高级的话题</h2><ol>
<li>分枝条件：<code>|</code>类似于编程中的<em>或</em>，指的是有几种规则，如果满足其中任意一种规则都应该当成匹配</li>
<li>分组：用小括号来指定<em>子表达式</em></li>
<li><p>反义：</p>
<p> 代码/语法 | 说明 </p>
<ul>
<li>| -<br>\W | 匹配任意不是字母，数字，下划线，汉字的字符<br>\S | 匹配任意不是空白符的字符<br>\D | 匹配任意非数字的字符<br>\B | 匹配不是单词开头或结束的位置<br>[^x] | 匹配除了x以外的任意字符<br>[^aeiou] | 匹配除了aeiou这几个字母以外的任意字符</li>
</ul>
</li>
<li><p>后向引用：使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号。<br> <code>后向引用</code>用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本。</p>
</li>
<li>零宽断言：查找在某些内容(但并不包括这些内容)之前或之后的东西。<br><code>(?=exp)</code>也叫<code>零宽度正预测先行断言</code>，它断言自身出现的位置的后面能匹配表达式exp。比如<code>\b\w+(?=ing\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配<code>sing</code>和<code>danc</code>。</li>
<li>负向零宽断言：确保某个字符没有出现，但并不想去匹配它</li>
<li>贪婪与懒惰：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）<code>匹配尽可能多的字符</code>。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。</li>
<li>平衡组/递归匹配</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/15/2017-7-15-AsyncAwaitTran/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HouXingYi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HouXingYi's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/15/2017-7-15-AsyncAwaitTran/" class="post-title-link" itemprop="url">[译]在10分钟内解释JavaScript Async/Await</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-15T00:00:00+08:00">2017-07-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-29 20:12:26" itemprop="dateModified" datetime="2018-07-29T20:12:26+08:00">2018-07-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/翻译/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文:https://tutorialzine.com/2017/07/javascript-async-await-explained</span><br><span class="line">作者:Danny Markov</span><br></pre></td></tr></table></figure>
<p>在很长的一段时间里，JavaScript开发者不得不依靠回调函数去处理异步代码。结果，我们大部分都经历过回调地狱和遇到<a href="https://tutorialzine.com/media/2017/07/callback-hell.jpg" target="_blank" rel="noopener">这样</a>功能的恐怖。</p>
<p>幸运的是，接下来（或者我们应该说 .then()）我们迎来了Promises. 他们提供了一个更组织化的回调方式，大多数社区迅速的转而使用它。</p>
<p>现在，随着最新版本的Async/Await出现，写JavaScript代码更爽了。</p>
<h2 id="什么是Async-Await？"><a href="#什么是Async-Await？" class="headerlink" title="什么是Async/Await？"></a>什么是Async/Await？</h2><p>Async/Await是一个很久就令人期待的JavaScript功能，它让使用异步函数更加愉快和容易理解。它是基于Promises的并且和现存的所有基于Promises的API相兼容。</p>
<p>从async和await这两个名字来的这两个关键字将会帮助我们整理我们的异步代码。</p>
<p>Async - 声明一个异步函数（async function someName(){…}）。</p>
<ul>
<li>自动将一个常规函数转化为一个Promise。</li>
<li>当调用async函数的时候，它用函数内返回的任何值来解决（resolve）。</li>
<li>异步函数可以使用await</li>
</ul>
<p>Await-暂停执行async函数（var result = await someAsyncCall();）。</p>
<ul>
<li>当放在一个Promise前面执行，await强制剩下的代码等待直到那个Promise结束并且返回一个结果</li>
<li>Await只有和Promise一起使用才有用，和回调函数（普通函数）一起使用不会产生作用</li>
<li>Await只可以在async函数内部使用</li>
</ul>
<p>这里有一个简单的例子，希望能帮你把事情理清楚：</p>
<p>假设我们想从我们的服务器中得到一些JSON文件。我们将写一个函数用axios库发送一个http GET 请求到<a href="https://tutorialzine.com/misc/files/example.json。" target="_blank" rel="noopener">https://tutorialzine.com/misc/files/example.json。</a> 我们不得不等待服务器响应，所以很自然这个HTTP 请求是异步的。</p>
<p>下面我们可以看到相同的功能实现了两次。首先是用Promises，然后第二次用Async / Await。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Promise 实现方式</span><br><span class="line">function getJSON()&#123;</span><br><span class="line"></span><br><span class="line">    // 为了让函数阻塞我们手动创建了一个Promise</span><br><span class="line">    return new Promise( function(resolve) &#123;</span><br><span class="line">        axios.get(&apos;https://tutorialzine.com/misc/files/example.json&apos;)</span><br><span class="line">            .then( function(json) &#123;</span><br><span class="line">                // 从请求来的数据可以从.then中得到</span><br><span class="line">                // 我们使用resolve返回结果</span><br><span class="line">                resolve(json);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Async/Await 实现方式</span><br><span class="line">// async关键字将会自动创建一个新的Promise并返回。</span><br><span class="line">async function getJSONAsync()&#123;</span><br><span class="line">    // await关键词使我们免于写一个.then()</span><br><span class="line">    let json = await axios.get(&apos;https://tutorialzine.com/misc/files/example.json&apos;);</span><br><span class="line">    // GET请求的结果可以从json变量中得到</span><br><span class="line">    // 我们把结果就像一个普通的同步函数一样返回</span><br><span class="line">    return json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显Async/Await版本的代码更短并且可读性更强。除了使用的语法，两个函数完全相同-他们都返回Promises并且都从axios得到JSON返回。我们可以像这样调用我们的async函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getJSONAsync().then( function(result) &#123;</span><br><span class="line">    // Do something with result.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="那么，Async-Await-让-Promises-过时了吗？"><a href="#那么，Async-Await-让-Promises-过时了吗？" class="headerlink" title="那么，Async/Await 让 Promises 过时了吗？"></a>那么，Async/Await 让 Promises 过时了吗？</h2><p>一点也不，当我们使用Async/Await其实底层还是在使用Promises。对Promises的良好理解在长远考虑下是对你是十分有帮助的并且也是高度推荐的。</p>
<p>这里甚至有一些情况Async/Await不能解决而我们不得不重新去寻求Promises的帮助。一种这样的场景是我们需要去调用多个独立的异步函数并等待他们所有完成。</p>
<p>假如我们尝试用async and await，以下就会发生:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function getABC() &#123;</span><br><span class="line">    let A = await getValueA(); // getValueA takes 2 second to finish</span><br><span class="line">    let B = await getValueB(); // getValueB takes 4 second to finish</span><br><span class="line">    let C = await getValueC(); // getValueC takes 3 second to finish</span><br><span class="line">    return A*B*C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个await将会等待前一个返回一个结果。因为我们一次只执行一个调用那么整个函数从开始到结束将会花9秒的时间（2+4+3）。</p>
<p>这不是一个最佳的解决方案，因为A,B和C互相并不依赖。换句话来说我们在得到B的时候我们并不需要A的值。我们可以同时得到这些值以减去几秒钟的等待时间。</p>
<p>同时发送所有的requests我们需要Promise.all()。这将会保证我们在进行下一步的时候我们可以得到所有的结果，但是所有的异步函数将会平行的运行，而不是一个接一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function getABC() &#123;</span><br><span class="line">  // Promise.all() allows us to send all requests at the same time. </span><br><span class="line">  let results = await Promise.all([ getValueA, getValueB, getValueC ]); </span><br><span class="line"></span><br><span class="line">  return results.reduce((total,value) =&gt; total * value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式函数将会花费少的多的时间，在getValueB结束的时候getValueA和getValueC就已经结束了。我们将有效的减少执行的时间到最慢的请求而不是时间的总和。</p>
<h2 id="处理Async-Await的错误"><a href="#处理Async-Await的错误" class="headerlink" title="处理Async/Await的错误"></a>处理Async/Await的错误</h2><p>另一个关于Async/Await很棒的事是它允许我们用很棒的老式try/catch块去catch任何意外的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function doSomethingAsync()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // This async call may fail.</span><br><span class="line">        let result = await someAsyncCall();</span><br><span class="line">    &#125;</span><br><span class="line">    catch(error) &#123;</span><br><span class="line">        // If it does we will catch the error here.</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何我们写在try块中的等待的异步调用或者其他任何错误代码，catch都能解决他们引起的错误（error）。</p>
<p>如果情况需要，我们也可以在执行async函数的时候抓取错误。由于所有异步函数返回Promises，所以我们可以在调用它们时简单地包含.catch()事件处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 不包含try/catch块的async函数</span><br><span class="line">async function doSomethingAsync()&#123;</span><br><span class="line">    // 这个async调用也许会失败</span><br><span class="line">    let result = await someAsyncCall();</span><br><span class="line">    return result;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们catch错误在调用async函数的时候</span><br><span class="line">doSomethingAsync().</span><br><span class="line">    .then(successHandler)</span><br><span class="line">    .catch(errorHandler);</span><br></pre></td></tr></table></figure>
<p>重要的是选择一种你喜欢的错误处理的方式，并坚持使用它。同时使用try/catch和.catch(）将很有可能导致一些问题。</p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>Async/Await已经支持大部分的主流浏览器。绝大多数的厂商将会识别你的async/await代码而不需要额外的库-除了IE11.</p>
<p>Node开发者只要node8或以上就可以享受到改进的异步流。它在今年晚些时候应该会变成LTS（ Long Term Support ）版本。</p>
<p>如果这兼容性不能满足你，也有许多像Babel和TypeScript和Nodejs库asyncawait这样的JS transpiler（源码转换器）提供他们自己的跨平台版本的功能。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>随着Async/Await ，JavaScript语言在代码可读性和易用性上向前迈进了一大步。能够编写类似于常规同步功能的异步代码将会受到JavaScript初学者和经验丰富的编程人员的赞赏。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/10/2017-6-10-know_everything_about_this/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HouXingYi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HouXingYi's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/10/2017-6-10-know_everything_about_this/" class="post-title-link" itemprop="url">理解JS的this关键字</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-10T00:00:00+08:00">2017-06-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-29 20:12:26" itemprop="dateModified" datetime="2018-07-29T20:12:26+08:00">2018-07-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><p>this是JavaScript中一个关键字，this提供了一种优雅的方式来隐式传递一个对象引用，因此可以把API设计得更加简洁并且易于复用。<br>但是，在平常使用中经常会对this产生一些误解，比较常见的会认为this“指向自身”或者“指向函数的作用域”  </p>
<h3 id="指向自身"><a href="#指向自身" class="headerlink" title="指向自身"></a>指向自身</h3><p>对于这个误解可以看下以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    this.a = 1;</span><br><span class="line">&#125;</span><br><span class="line">foo.a = 0;</span><br><span class="line">foo();</span><br><span class="line">console.log(foo.a);//0</span><br><span class="line">console.log(this.a);//1</span><br><span class="line">console.log(window.a);//1</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码可以看到，this并不指向foo而是指向了window，可见this指向自身并不成立</p>
<h3 id="指向函数的作用域"><a href="#指向函数的作用域" class="headerlink" title="指向函数的作用域"></a>指向函数的作用域</h3><p>这也是个常见的误解,请看一下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">function bar()&#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">foo();//undefined</span><br></pre></td></tr></table></figure></p>
<p>这段代码，希望利用this向上查找到a，代替作用域的效果，但并没有成功。</p>
<h3 id="this究竟是什么"><a href="#this究竟是什么" class="headerlink" title="this究竟是什么"></a>this究竟是什么</h3><p>通过以上一些例子，我们可以看到，this的指向飘忽不定,在不同的场景下，this会化身不同的对象。如果不了解this的机制就很难猜到this的指向。<br>那么this究竟是什么？<br><strong><em>先上结论：实际上，this是在运行的时候进行绑定的，并不是在编写时绑定，它指向什么完全取决于函数在哪里被调用。</em></strong></p>
<h2 id="this绑定规则"><a href="#this绑定规则" class="headerlink" title="this绑定规则"></a>this绑定规则</h2><p>要确定this的值，首先要看函数的调用位置。找到调用位置后，需要判断应用下面四条规则的哪一条</p>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>这条规则是无法应用其他规则时的默认规则,请看以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo();//2</span><br></pre></td></tr></table></figure></p>
<p>在这里，foo()是直接进行调用，因此只能使用默认绑定，this指向全局对象。</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>这种情况是函数是被某个上下文对象调用的，比如下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    a:3,</span><br><span class="line">    foo:function()&#123;</span><br><span class="line">        console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.foo();</span><br></pre></td></tr></table></figure></p>
<h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>隐式绑定一个常见的问题是被隐式绑定的函数会丢失绑定对象，比较常见的情况如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">function doFoo(fn)&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a : 2,</span><br><span class="line">    foo : foo</span><br><span class="line">&#125;</span><br><span class="line">var a = &quot;global&quot;;</span><br><span class="line">doFoo(obj.foo);//global</span><br></pre></td></tr></table></figure></p>
<p>这里没有如预想的应用隐式绑定，而是应用了默认绑定，将this绑定到全局对象上了，这种情况在应用隐式绑定的时候经常遇到。</p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>显式绑定通过call()或apply()方法，用于显式的指定this的绑定对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a : 2</span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj);// 2</span><br></pre></td></tr></table></figure></p>
<h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><p>但是，显式绑定并没有解决我们之前提出的丢失绑定问题，但是显式绑定的一个变种可以解决这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">    console.log( this.a,something );</span><br><span class="line">    return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line">function bind(fn,obj)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return fn.apply(obj,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function doFoo(fn,arg)&#123;</span><br><span class="line">    fn(arg);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a:2</span><br><span class="line">&#125;;</span><br><span class="line">var bar = bind(foo,obj);</span><br><span class="line">doFoo(bar,3);// 2 3</span><br></pre></td></tr></table></figure></p>
<p>这里，我们创建了一个bind函数用于绑定函数与上下文对象，这种模式称为<em>硬绑定</em>。<br>ES5中提供了内置的bind方法</p>
<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>在JS中，对函数使用new操作符的时候，我们称此函数为构造函数，或者更准确的说，对这个函数进行了“构造调用”。<br>使用new来调用函数，会自动执行下面的操作。</p>
<ol>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行[[Prototype]]连接(新对象的<em>proto</em>指向函数的原型)</li>
<li>这个新对象会绑定到函数调用的this</li>
<li>如果函数没有返回，自动返回这个新对象  </li>
</ol>
<p>new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。如果某个调用位置可以应用多条，我们按照优先级应用这四条规则。  </p>
<ol>
<li>函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。 </li>
<li>函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。</li>
<li>函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this绑定的是那个上下文对象。</li>
<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。</li>
</ol>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>一般情况下通过以上四种规则就可以理解大部分的this的使用情况。当然除了这些一般的情况下也有一些例外，比如ES6的箭头函数中的this会继承外层函数调用的this绑定。碰到这些例外情况就具体情况具体分析了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/20/2017-5-20-gra/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HouXingYi"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HouXingYi's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/20/2017-5-20-gra/" class="post-title-link" itemprop="url">毕业了</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-05-20T00:00:00+08:00">2017-05-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-29 20:12:26" itemprop="dateModified" datetime="2018-07-29T20:12:26+08:00">2018-07-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日常/" itemprop="url" rel="index"><span itemprop="name">日常</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="留些纪念"><a href="#留些纪念" class="headerlink" title="留些纪念"></a>留些纪念</h2><p>毕业了，心里挺复杂的，但也不是悲伤，愿大家前程似锦。贴些照片留作纪念。</p>
<h2 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h2><p><img src="/images/graduate/9.jpg" alt="memory"></p>
<p><img src="/images/graduate/8.jpg" alt="memory"></p>
<p><img src="/images/graduate/7.jpg" alt="memory"></p>
<p><img src="/images/graduate/6.jpg" alt="memory"></p>
<p><img src="/images/graduate/5.jpg" alt="memory"></p>
<p><img src="/images/graduate/4.jpg" alt="memory"></p>
<p><img src="/images/graduate/3.jpg" alt="memory"></p>
<p><img src="/images/graduate/2.jpg" alt="memory"></p>
<p><img src="/images/graduate/1.jpg" alt="memory"></p>
<p><img src="/images/graduate/10.jpg" alt="memory"></p>
<p><img src="/images/graduate/11.jpg" alt="memory"></p>
<p><img src="/images/graduate/12.jpg" alt="memory"></p>
<p><img src="/images/graduate/13.jpg" alt="memory"></p>
<p><img src="/images/graduate/14.jpg" alt="memory"></p>
<p><img src="/images/graduate/15.jpg" alt="memory"></p>
<p><img src="/images/graduate/16.jpg" alt="memory"></p>
<p><img src="/images/graduate/17.jpg" alt="memory"></p>
<p>诶嘿！哪个是我呢！<br><img src="/images/life/gakki.gif" alt="memory"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="HouXingYi"/>
            
              <p class="site-author-name" itemprop="name">HouXingYi</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HouXingYi</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  

  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
